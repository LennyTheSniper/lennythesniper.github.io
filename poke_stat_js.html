<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pokémon Stat Viewer</title>
  <link rel="icon" type="image/x-icon" href="./images/favicon.ico">
  <style>
    :root{
      /* Light theme defaults */
      --bg: #ffffff;
      --text: #111111;
      --muted: #666666;
      --sprite-bg: #f0f0f0;
      --stat-canvas-bg: #f8f8f8;
      --bar-unfilled: #e8e8e8;
      --control-bg: #ffffff;
      --accent: #d9534f;
      --error: #d9534f; /* EV overflow / error color for light theme */
    }
    .dark{
      /* Dark theme overrides */
      --bg: #0f1720;
      --text: #e6eef6;
      --muted: #9aa7bb;
      --sprite-bg: #1f2937;
      --stat-canvas-bg: #111827;
      --bar-unfilled: #2a3440;
      --control-bg: #0b1220;
      --accent: #ff8b8b;
      --error: #ff8b8b; /* EV overflow / error color for dark theme */
    }

    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 12px; background:var(--bg); color:var(--text); }
    .top { display:flex; gap:12px; align-items:flex-start; }
    label { font-weight:600; color:var(--text); }
    select, input[type=text], input[type=number] { padding:6px 8px; font-size:14px; background:var(--control-bg); color:var(--text); border:1px solid rgba(0,0,0,0.08); }
    .sprite { width:128px; height:128px; display:inline-block; background:var(--sprite-bg); border-radius:8px; overflow:hidden; }
    .types { 
      display: flex; 
      flex-direction: column; 
      gap: 6px; 
      align-items: flex-start;
      margin-top: 8px;
    }
    .type-img { 
      width: 144px; 
      height: 30px; 
      position: static; /* remove absolute positioning */
      transform: none; 
    }
    .abilities { flex:1; white-space:pre-wrap; color:var(--text); }
    .stats { margin-top:14px; }
    .stat-row { display:flex; align-items:center; gap:8px; margin-bottom:8px; }
    .stat-label { width:44px; text-align:left; color:var(--text); }
    .stat-canvas { background:var(--stat-canvas-bg); width:420px; height:24px; border-radius:4px; }
    .val-label { width:90px; color:var(--muted); }
    .iv-ev { display:flex; gap:6px; align-items:center; }
    .ev-buttons button { width:28px; }
    footer { margin-top:12px; display:flex; justify-content:space-between; align-items:center; }
    .status { font-size:13px; color:#444; }
    .ev-total { font-weight:700; color:var(--text); transition: color 120ms ease; }
    .ev-total.over { color: var(--error); }
    .note { font-size:12px; color:#666; }
    .controls { display:flex; gap:8px; align-items:center; }
    .credits { display:flex; gap:8px; align-items:center; }
  </style>
</head>
<body>
  <header style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
    <h2 style="margin:0;">Pokémon Stat Viewer</h2>
    <div style="display:flex; gap:8px; align-items:center;">
      <button id="theme-toggle" aria-label="Toggle theme" style="padding:6px 10px; font-size:14px; border-radius:6px; cursor:pointer;">Dark mode</button>
    </div>
  </header>
  <div class="top">
    <div style="min-width:340px;">
      <div style="margin-bottom:8px; display:flex; gap:8px; align-items:center;">
        <label for="pokemon-select">Pokémon:</label>
        <select id="pokemon-select" size="1" style="width:260px;"></select>
      </div>
      <div style="margin-bottom:8px; display:flex; gap:8px; align-items:center;">
        <label for="form-select">Form / Variety:</label>
        <select id="form-select" style="width:320px;"></select>
      </div>

      <div style="display:flex; gap:12px; align-items:flex-start;">
        <div>
          <div class="sprite" id="sprite-box"><img id="sprite-img" alt="sprite" style="max-width:100%; height:auto; display:none; margin:auto;"/></div>
        </div>
        <div style="display:flex; flex-direction:column; align-items:center;">
          <div class="types">
            <img id="type1" class="type-img type1" alt="type1" style="display:none;" />
            <img id="type2" class="type-img type2" alt="type2" style="display:none;" />
          </div>
          <div class="abilities" id="abilities-box"></div>
        </div>
      </div>
    </div>
    <div style="flex:1;">
      <div class="stats" id="stats-area"></div>
    </div>
  </div>

  <footer>
    <div class="controls">
      <label>Level:</label>
      <input id="level-input" type="number" min="1" value="100" style="width:80px;" />
      <div class="note">(EVs may end with + / - to apply +10% / -10% nature multiplier)</div>
    </div>
    <label>Made by: LennyTheSniper</label>
    <div class="status" id="status">Loading...</div>
  </footer>

  <script>
  // JavaScript port of PokeStat.py behaviour
  const API_BASE = 'https://pokeapi.co/api/v2';
  const LIST_ENDPOINT = API_BASE + '/pokemon?limit=1025';

  const STAT_KEYS = ["hp","attack","defense","special-attack","special-defense","speed"];
  const STAT_LABELS = ["HP","Atk","Def","SpA","SpD","Spe"];

  // color constants from Python
  const COLOR_DARK_RED = '#aa2323';
  const COLOR_RED = '#d9534f';
  const COLOR_ORANGE = '#f0ad4e';
  const COLOR_YELLOW = '#f7e35a';
  const COLOR_GREEN = '#5cb85c';
  const COLOR_LIGHTBLUE = '#5bc0de';
  const COLOR_PURPLE = '#a65bcc';
  const COLOR_PINK = '#FF32A9';

  const TYPE_ICON_GITHUB_TEMPLATE = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/types/generation-ix/scarlet-violet/{id}.png';
  const TYPE_ICON_LEGACY_BY_NAME = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/types/{type_name}.png';
  const TYPE_API_ENDPOINT = API_BASE + '/type/{type_name}';
  const TYPE_ID_CACHE = {};

  // helpers: color conversions and lerp
  function hexToRgb(hex) {
    hex = hex.replace('#','');
    return [parseInt(hex.substring(0,2),16), parseInt(hex.substring(2,4),16), parseInt(hex.substring(4,6),16)];
  }
  function rgbToHex(rgb){
    return '#'+rgb.map(v=>v.toString(16).padStart(2,'0')).join('');
  }
  function lerpColor(c1,c2,t){
    const a = hexToRgb(c1); const b = hexToRgb(c2);
    const r = Math.round(a[0] + (b[0]-a[0])*t);
    const g = Math.round(a[1] + (b[1]-a[1])*t);
    const bl = Math.round(a[2] + (b[2]-a[2])*t);
    return rgbToHex([r,g,bl]);
  }

  // Pokemon stat formulas
  function calc_hp(base, iv, ev, level=100){
    if (base !== 1) {
      return Math.floor(((2*base + iv + Math.floor(ev/4)) * level)/100) + level + 10;
    } else {
      return 1;
    }
  }
  function calc_other(base, iv, ev, level=100, nature_mult=1.0){
    let v = Math.floor(((2*base + iv + Math.floor(ev/4)) * level)/100 + 5);
    v = Math.floor(v * nature_mult);
    return v;
  }

  // global min/max functions
  function global_min_hp(level){ return calc_hp(5,0,0,level); }
  function global_max_hp(level){ return calc_hp(255,31,252,level); }
  function global_min_other(level){ return calc_other(5,0,0,level,1.0); }
  function global_max_other(level){ return calc_other(255,31,252,level,1.1); }

  // fetch helpers
  async function fetchJson(url){
    const res = await fetch(url);
    if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
    return await res.json();
  }

  async function fetchAllPokemonList(){
    const data = await fetchJson(LIST_ENDPOINT);
    return (data.results || []).map(r=>r.name);
  }

  async function fetchSpecies(nameOrUrl){
    let url = nameOrUrl.startsWith('http') ? nameOrUrl : `${API_BASE}/pokemon-species/${nameOrUrl}`;
    let r = await fetch(url);
    if (r.status === 404) {
      // fallback to /pokemon/<name>
      const alt = await fetchJson(`${API_BASE}/pokemon/${nameOrUrl}`);
      const species_name = alt.species.name;
      url = `${API_BASE}/pokemon-species/${species_name}`;
      r = await fetch(url);
    }
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return await r.json();
  }

  async function fetchPokemonByName(name){
    return await fetchJson(`${API_BASE}/pokemon/${name}`);
  }

  async function fetchTypeId(typeName){
    if (!typeName) return null;
    const key = typeName.trim().toLowerCase();
    if (TYPE_ID_CACHE[key]) return TYPE_ID_CACHE[key];
    try{
      const url = TYPE_API_ENDPOINT.replace('{type_name}', key);
      const data = await fetchJson(url);
      const tid = data.id;
      if (Number.isInteger(tid)) { TYPE_ID_CACHE[key] = tid; return tid; }
    }catch(e){ return null; }
    return null;
  }

  async function fetchTypeIconUrl(typeName){
    if (!typeName) return null;
    const t = typeName.trim().toLowerCase();
    const tid = await fetchTypeId(t);
    if (tid != null) return TYPE_ICON_GITHUB_TEMPLATE.replace('{id}', tid);
    return TYPE_ICON_LEGACY_BY_NAME.replace('{type_name}', t);
  }

  // parse int with suffix like python function
  function parseIntWithSuffix(s, defaultVal=0){
    s = (s||'').toString().trim();
    if (!s) return {val: defaultVal, suffix: ''};
    let suffix = '';
    if (s.endsWith('+') || s.endsWith('-')){ suffix = s.slice(-1); s = s.slice(0,-1).trim(); }
    let val = defaultVal;
    if (s !== ''){
      const n = parseInt(s,10);
      if (!Number.isNaN(n)) val = n; else val = defaultVal;
    }
    val = Math.max(0, val);
    return {val, suffix};
  }

  function chooseColorByThreshold(value, key, level=100){
    const colors = [COLOR_DARK_RED, COLOR_RED, COLOR_ORANGE, COLOR_YELLOW, COLOR_GREEN, COLOR_LIGHTBLUE, COLOR_PURPLE, COLOR_PINK];

    let band_values = [];
    if (key === 'hp'){
      const hp_bases = [ [20,0],[35,0],[50,0],[70,0],[90,252],[120,252],[150,252],[180,252] ];
      band_values = hp_bases.map(b => calc_hp(b[0],31,b[1],level));
    } else {
      const other_bases = [ [30,0,1.0],[45,0,1.0],[60,0,1.0],[80,0,1.0],[100,252,1.1],[130,252,1.1],[165,252,1.1],[190,252,1.1] ];
      band_values = other_bases.map(b => calc_other(b[0],31,b[1],level,b[2]));
    }

    let thresholds = colors.map((c,i)=>({c, v: band_values[i]}));
    thresholds.sort((a,b)=>a.v - b.v);
    if (value <= thresholds[0].v) return thresholds[0].c;
    if (value >= thresholds[thresholds.length-1].v) return thresholds[thresholds.length-1].c;
    for (let i=0;i<thresholds.length-1;i++){
      const c1 = thresholds[i].c, v1 = thresholds[i].v;
      const c2 = thresholds[i+1].c, v2 = thresholds[i+1].v;
      if (v1 <= value && value <= v2){
        const t = (v2===v1) ? 0.0 : ((value - v1)/(v2 - v1));
        return lerpColor(c1,c2,t);
      }
    }
    return thresholds[thresholds.length-1].c;
  }

  // Application state
  const state = {
    pokemonNames: [],
    currentSpecies: null,
    currentPokemonJson: null,
    varieties: [],
  };

  // DOM elements
  const pokemonFilter = document.getElementById('pokemon-filter');
  const pokemonSelect = document.getElementById('pokemon-select');
  const formSelect = document.getElementById('form-select');
  const spriteImg = document.getElementById('sprite-img');
  const type1Img = document.getElementById('type1');
  const type2Img = document.getElementById('type2');
  const abilitiesBox = document.getElementById('abilities-box');
  const statsArea = document.getElementById('stats-area');
  const levelInput = document.getElementById('level-input');
  const statusEl = document.getElementById('status');

  // Build stat rows (DOM)
  const statRows = {};
  function createStatRows(){
    statsArea.innerHTML = '';
    STAT_LABELS.forEach((lab,i)=>{
      const key = STAT_KEYS[i];
      const row = document.createElement('div'); row.className='stat-row';
      const label = document.createElement('div'); label.className='stat-label'; label.textContent = lab;
      const canvas = document.createElement('canvas'); canvas.className='stat-canvas'; canvas.width = 420; canvas.height = 24;
      const valLabel = document.createElement('div'); valLabel.className='val-label'; valLabel.textContent='--';
      const ivInput = document.createElement('input'); ivInput.type='text'; ivInput.value='31'; ivInput.style.width='38px';
      const evInput = document.createElement('input'); evInput.type='text'; evInput.value='0'; evInput.style.width='64px';
      const evButtons = document.createElement('div'); evButtons.className='ev-buttons';
      const minus = document.createElement('button'); minus.textContent='-';
      const plus = document.createElement('button'); plus.textContent='+';
      evButtons.appendChild(minus); evButtons.appendChild(plus);

      row.appendChild(label);
      row.appendChild(canvas);
      row.appendChild(valLabel);
      const ivev = document.createElement('div'); ivev.className='iv-ev';
      ivev.appendChild(ivInput); ivev.appendChild(evInput); ivev.appendChild(evButtons);
      row.appendChild(ivev);

      statsArea.appendChild(row);

      statRows[key] = {label, canvas, valLabel, ivInput, evInput};

      // events
      ivInput.addEventListener('change', ()=>{ updateDisplay(); });
      evInput.addEventListener('change', ()=>{ updateDisplay(); updateEvTotal(); });
      minus.addEventListener('click', ()=>{ adjustEv(key,-1); });
      plus.addEventListener('click', ()=>{ adjustEv(key,1); });
    });

    // EV total
    const totalRow = document.createElement('div'); totalRow.style.marginTop='6px';
    const evTotal = document.createElement('span'); evTotal.id='ev-total'; evTotal.className='ev-total'; evTotal.textContent='0/510';
    totalRow.appendChild(evTotal);
    statsArea.appendChild(totalRow);
  }

  createStatRows();

  function setStatus(t){ statusEl.textContent = t;}

  async function loadPokemonList(){
    setStatus('Loading Pokémon list...');
    try{
      const names = await fetchAllPokemonList();
      state.pokemonNames = names.sort((a,b)=>a.localeCompare(b));
      populatePokemonSelect();
      setStatus('Select a Pokémon from the dropdown.');
    }catch(e){ setStatus('Failed to load list'); alert('Could not fetch Pokémon list:\n'+e); }
  }

  function getFilteredPokemonNames(){
    const filt = (pokemonFilter.value||'').trim().toLowerCase();
    if (!filt) return [...state.pokemonNames];
    return state.pokemonNames.filter(n=>n.toLowerCase().includes(filt));
  }

  function populatePokemonSelect(){
    pokemonSelect.innerHTML = '';
    const blank = document.createElement('option');
    blank.value = '';
    blank.textContent = '--';
    pokemonSelect.appendChild(blank);
    state.pokemonNames.forEach(n=>{
      const opt = document.createElement('option');
      opt.value=n;
      opt.textContent=n;
      pokemonSelect.appendChild(opt);
    });
  }

  pokemonSelect.addEventListener('change', async ()=>{ const sel = pokemonSelect.value; if (!sel) return; setStatus('Loading species for '+sel+'...'); try{ const species = await fetchSpecies(sel); state.currentSpecies = species; const varieties = species.varieties || []; state.varieties = varieties.map(v=>({name:v.pokemon.name, is_default:!!v.is_default})); state.varieties.sort((a,b)=> (a.is_default? -1:1) - (b.is_default? -1:1) || a.name.localeCompare(b.name)); populateFormSelect(); setStatus('Species loaded. Choose a form.'); }catch(e){ alert('Failed to fetch species data for '+sel+':\n'+e); setStatus('Error fetching species.'); } });

  function populateFormSelect(){ formSelect.innerHTML=''; state.varieties.forEach(v=>{ const opt=document.createElement('option'); opt.value=v.name; opt.textContent=v.name; formSelect.appendChild(opt); }); if (state.varieties.length){ formSelect.selectedIndex = 0; onFormSelected(); } }

  async function onFormSelected(){ const formName = formSelect.value; if (!formName) return; setStatus('Loading form '+formName+'...'); try{ const pj = await fetchPokemonByName(formName); state.currentPokemonJson = pj; updateSprite(); populateStatEntries(); updateDisplay(); setStatus('Loaded '+formName+'.'); }catch(e){ alert('Failed to fetch pokemon data for '+formName+':\n'+e); setStatus('Error fetching form.'); } }

  async function updateSprite(){ const pj = state.currentPokemonJson; spriteImg.src = ''; type1Img.src=''; type2Img.src=''; abilitiesBox.textContent = '';
    // choose artwork
    const sprites = pj.sprites || {};
    const other = sprites.other || {};
    const official = other['official-artwork'] || {};
    let url = official.front_default || sprites.front_default;
    if (!url){ for (const k of ['front_shiny','back_default','back_shiny']){ if (sprites[k]){ url = sprites[k]; break; } } }
    if (url) {
      spriteImg.src = url;
      spriteImg.style.display = "block";
    } else {
      spriteImg.style.display = "none";
    }


    // types
    const types = (pj.types || []).slice().sort((a,b)=> (a.slot||0)-(b.slot||0));
    const primary = types[0] ? types[0].type.name : null;
    const secondary = types[1] ? types[1].type.name : null;
    // load icons (non-fatal)
    try{
      const t1url = await fetchTypeIconUrl(primary);
      const t2url = await fetchTypeIconUrl(secondary);
    if (t1url) {
            type1Img.style.display = "block";
            type1Img.src = t1url;
          } else {
            type1Img.style.display = "none";
          }
    if (t2url) {
            type2Img.style.display = "block";
            type2Img.src = t2url;
          } else {
            type2Img.style.display = "none";
          }
    }catch(e){ /* ignore icon errors */ }

    // abilities display
    const abilities = (pj.abilities || []).slice().sort((a,b)=> (a.is_hidden?1:0) - (b.is_hidden?1:0) || (a.slot||0)-(b.slot||0));
    const non_hidden = abilities.filter(a=>!a.is_hidden);
    const hidden = abilities.filter(a=>a.is_hidden);
    const parts = [];
    if (non_hidden[0]) parts.push('\n\n1. '+non_hidden[0].ability.name.replace(/-/g,' ').replace(/\b\w/g,c=>c.toUpperCase()));
    if (non_hidden[1]) parts.push('2. '+non_hidden[1].ability.name.replace(/-/g,' ').replace(/\b\w/g,c=>c.toUpperCase()));
    let ha_text = '';
    if (hidden[0]) {
      const haLine = 'HA. ' + hidden[0].ability.name
        .replace(/-/g,' ')
        .replace(/\b\w/g,c=>c.toUpperCase());
      // wrap in italics
      parts.push('<i>' + haLine + '</i>');
      ha_text = haLine;
    }

    // use innerHTML so italics render, preserve line breaks
    abilitiesBox.innerHTML = parts.join('<br>');
  }

  function populateStatEntries(){ // nothing special, defaults already set
  }

  function computeStatValues(){
    if (!state.currentPokemonJson) return {};
    const level = parseInt(levelInput.value)||100;
    const base_map = {};
    (state.currentPokemonJson.stats||[]).forEach(s=>{ base_map[s.stat.name] = s.base_stat; });
    const result = {};
    for (const key of STAT_KEYS){
      const row = statRows[key];
      const ivText = row.ivInput.value || '31';
      const evText = row.evInput.value || '0';
      const iv = Math.max(0, Math.min(31, parseInt(parseIntWithFallback(ivText,31))));
      const parsedEv = parseIntWithSuffix(evText,0);
      let ev = parsedEv.val; const suffix = parsedEv.suffix;
      ev = Math.max(0, Math.min(252, ev));
      let nature_mult = 1.0; if (suffix === '+') nature_mult = 1.1; else if (suffix === '-') nature_mult = 0.9;
      const base = base_map[key] || 0;
      const value = (key==='hp') ? calc_hp(base, iv, ev, level) : calc_other(base, iv, ev, level, nature_mult);
      const minv = (key==='hp') ? global_min_hp(level) : global_min_other(level);
      const maxv = (key==='hp') ? global_max_hp(level) : global_max_other(level);
      let pct = 0.0; if (maxv > minv) { pct = (value - minv)/(maxv - minv); pct = Math.max(0, Math.min(1, pct)); }
      result[key] = { value: Math.floor(value), base: base, iv: iv, ev: ev, ev_suffix: suffix, nature_mult: nature_mult, pct, minv, maxv };
    }
    return result;
  }

  function parseIntWithFallback(s, fallback){ const n = parseInt(s,10); return Number.isNaN(n)?fallback:n; }

  function updateDisplay(){
    if (!state.currentPokemonJson) return;
    const statsInfo = computeStatValues();
    for (const key of STAT_KEYS){
      const info = statsInfo[key];
      const row = statRows[key];
      const canvas = row.canvas; const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (!info){ row.valLabel.textContent='--'; continue; }
      const value = info.value; const pct = info.pct; const level = parseInt(levelInput.value)||100;
      const color = chooseColorByThreshold(value, key, level);
      const w = canvas.width, h = canvas.height; const padding = 2; const innerW = w - padding*2; const filledW = Math.max(2, Math.floor(innerW * pct));
      // background (use CSS var)
      const barBg = getCssVar('--bar-unfilled') || '#e8e8e8';
      const textColor = getCssVar('--text') || '#000';
      ctx.fillStyle = barBg; ctx.fillRect(padding, padding, innerW, h - padding*2);
      // filled (unchanged logic, colors still come from chooseColorByThreshold)
      ctx.fillStyle = color; ctx.fillRect(padding, padding, filledW, h - padding*2);
      // text (use theme text color)
      ctx.font = 'bold 12px system-ui'; ctx.fillStyle = textColor; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(String(value), w/2, h/2);
      row.valLabel.textContent = 'base '+String(info.base);
    }
    const name = state.currentPokemonJson.name || '';
    setStatus('Showing '+name+' at Lv'+(levelInput.value||'100')+' (31 IV default)');
    updateEvTotal();
  }

  function updateEvTotal(){
    let total = 0;
    for (const k of STAT_KEYS){
      const r = statRows[k];
      const parsed = parseIntWithSuffix(r.evInput.value||'0',0);
      let v = parsed.val; v = Math.max(0, Math.min(252, v));
      total += v;
    }
    const evTotalEl = document.getElementById('ev-total');
    evTotalEl.textContent = total + '/510';
    // toggle a class so the color comes from the theme CSS (no hard-coded colors)
    evTotalEl.classList.toggle('over', total > 510);
  }


  // Adjust EV algorithm replicating Python behavior
  function statAtForKey(key, base, iv_val, ev_candidate, level, nature_mult){ if (key==='hp') return calc_hp(base, iv_val, ev_candidate, level); return calc_other(base, iv_val, ev_candidate, level, nature_mult); }

  function adjustEv(key, direction){ if (![1,-1].includes(direction)) return; const row = statRows[key]; const parsed = parseIntWithSuffix(row.evInput.value||'0',0); let ev_val = Math.max(0, Math.min(252, parsed.val)); const ev_suffix = parsed.suffix; let iv_val = parseIntWithFallback(row.ivInput.value,31); iv_val = Math.max(0, Math.min(31, iv_val)); let nature_mult = 1.0; if (ev_suffix === '+') nature_mult = 1.1; else if (ev_suffix === '-') nature_mult = 0.9; const base_map = {}; (state.currentPokemonJson.stats||[]).forEach(s=>{ base_map[s.stat.name]=s.base_stat; }); const base = base_map[key]||0; const level = parseInt(levelInput.value)||100; const cur_stat = statAtForKey(key, base, iv_val, ev_val, level, nature_mult);
    // compute total EVs
    let total_ev = 0; for (const k of STAT_KEYS){ const v = parseIntWithSuffix(statRows[k].evInput.value||'0',0).val; total_ev += Math.max(0, Math.min(252, v)); }

    if (direction > 0){
      if (ev_val >= 252) return;
      if (total_ev + 4 > 510) return;
      let chosen = null;
      if (level >= 100){ chosen = ev_val + 4; }
      else{
        for (let candidate=ev_val+1; candidate<=252; candidate++){
          const d = candidate - ev_val; if (total_ev + d > 510) break; if (statAtForKey(key, base, iv_val, candidate, level, nature_mult) >= cur_stat + 1){ chosen = candidate; break; } }
        if (chosen === null) return; }
      let new_ev = Math.max(0, Math.min(252, chosen)); row.evInput.value = String(new_ev) + (ev_suffix ? ev_suffix : '');
    } else {
      const target_stat = cur_stat - 1; if (target_stat < 0) return; let chosen = null; if (level >= 100){ chosen = Math.max(0, ev_val - 4); } else{
        for (let candidate=0; candidate<ev_val; candidate++){ if (statAtForKey(key, base, iv_val, candidate, level, nature_mult) === target_stat){ chosen = candidate; break; } }
        if (chosen === null) return; }
      let new_ev = Math.max(0, Math.min(252, chosen)); row.evInput.value = String(new_ev) + (ev_suffix ? ev_suffix : '');
    }
    updateDisplay(); updateEvTotal(); }

  // Utility parseIntWithSuffix used above
  function parseIntWithSuffix(s, defaultVal=0){ s = (s||'').toString().trim(); if (!s) return {val: defaultVal, suffix: ''}; let suffix=''; if (s.endsWith('+')||s.endsWith('-')){ suffix = s.slice(-1); s = s.slice(0,-1).trim(); } let val = defaultVal; if (s!==''){ const n = parseInt(s,10); if (!Number.isNaN(n)) val=n; else val = defaultVal; } val = Math.max(0,val); return {val, suffix}; }

  // QuickType behavior for formSelect: type characters to jump to form starting with prefix
  (function attachQuickType(elem){ let buffer=''; let timer=null; const timeout=1000; elem.addEventListener('keydown', (e)=>{ if (e.key === 'Backspace'){ buffer = buffer.slice(0,-1); scheduleReset(); if (buffer) selectByPrefix(buffer); e.preventDefault(); return; } if (e.key.length===1 && e.key.match(/\S/)) { buffer += e.key; scheduleReset(); selectByPrefix(buffer); e.preventDefault(); return; } if (e.key === 'Enter') return; }); function scheduleReset(){ if (timer) clearTimeout(timer); timer = setTimeout(()=>{ buffer=''; timer=null; }, timeout); } async function selectByPrefix(pref){ if (!pref) return; const options = Array.from(elem.options).map(o=>o.value); const lp = pref.toLowerCase(); for (const v of options){ if (v && v.toLowerCase().startsWith(lp)){ elem.value = v; // trigger change
            onFormSelected(); return; } } } })(formSelect);

  // Level input hooks
  levelInput.addEventListener('change', ()=>{ let lv = parseInt(levelInput.value)||100; if (lv<1) lv=1; levelInput.value = lv; updateDisplay(); });

  // Form select change
  formSelect.addEventListener('change', ()=>{ onFormSelected(); });
  
    // --- Theme helpers for light/dark mode ---
  function getCssVar(name){
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }

  function applyThemeClass(isDark){
    if (isDark) document.documentElement.classList.add('dark');
    else document.documentElement.classList.remove('dark');
    const btn = document.getElementById('theme-toggle');
    if (btn) btn.textContent = isDark ? 'Light mode' : 'Dark mode';
    // redraw canvases so colors update
    try{ updateDisplay(); }catch(e){}
  }

  const themeToggleBtn = document.getElementById('theme-toggle');
  if (themeToggleBtn){
    themeToggleBtn.addEventListener('click', ()=>{
      const nowDark = !document.documentElement.classList.contains('dark');
      applyThemeClass(nowDark);
      localStorage.setItem('theme', nowDark ? 'dark' : 'light');
    });
  }

  // initialize theme from localStorage or system preference
  (function(){
    const saved = localStorage.getItem('theme');
    if (saved === 'dark') applyThemeClass(true);
    else if (saved === 'light') applyThemeClass(false);
    else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) applyThemeClass(true);
    else applyThemeClass(false);
  })();
  // --- end theme helpers ---


  // initialize
  loadPokemonList();

  </script>
</body>
</html>